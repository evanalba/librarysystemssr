Packages:
Mocha - A JavaScript test framework for Node.js programs.

Chai - A BDD / TDD assertion library for node and the browser that can be
delightfully paired with any javascript testing framework.

Jest - Maybe for frontend?

Standard name of Compose filename:
https://docs.docker.com/compose/intro/compose-application-model/

```
your-project/
├── backend/
│   ├── src/  contains everything that makes your server-side application run.
                These files are processed on the server and are not directly
                accessible from the user's browser.
│   │   ├── app.js       # Your main Express.js application file
│   │   └── routes/      # Your server-side routing logic
│   │   └── models/      # Your database interaction logic
│   │
│   ├── public/ The public/ folder is where you put all of your static files.

These are assets that are intended to be served directly to the client's web
browser without any server-side processing. Your Express.js server is
configured to make these files publicly accessible.

Static Assets: This is where you store files like:

bootstrap.min.css: Your CSS stylesheets.

bootstrap.bundle.min.js: Your JavaScript files.

images/: Any images your website uses.

index.html: A static HTML file, if you're not using a template engine like EJS.

The purpose of the public/ folder is to act as the web-facing part of your
application. When a user requests http://yourdomain.com/css/bootstrap.min.css,
your Express.js server looks for that file in the public/ directory and sends
it directly to the browser.

│   │   ├── css/
│   │   │   └── bootstrap.min.css
│   │   ├── js/
│   │   │   └── bootstrap.bundle.min.js
│   │   └── index.html   # Your Bootstrap frontend files
│   │
│   ├── views/           # Optional: For your EJS templates
│   │   └── index.ejs
│   │
│   ├── Dockerfile
│   ├── package.json
│   └── package-lock.json
│
├── db/
│   └── password.txt     # Your database password file for Docker secrets
│
└── compose.yaml
```

-----

### Key Takeaways from This Structure

  * Single-Source of Truth: All your application code, both frontend
  and backend, now lives under the **`backend/`** directory. This is the
  hallmark of a monolithic application.
  
  * Docker Context: The `backend/` directory serves as the **build
  context** for your `backend` service in `docker-compose.yml`. When Docker
  builds the image, it will copy everything from this directory, including
  your static `public` assets and `EJS` views.
  
  * Static Files: Your Bootstrap files are placed in a `public/`
  directory, which your Express.js server will be configured to serve
  as static assets.
  
  * No Separate Frontend: The `frontend/` folder is gone, as your
  `docker-compose.yml` no longer needs a separate service to handle it.
  Your single `backend` service is now responsible for everything.


The purpose of the **`views`** folder is to store the **templates** your web 
application uses to render dynamic HTML. It is a key part of the server-side 
rendering process in frameworks like Express.js.

The content in this folder is not directly accessible to a user's web browser. 
Instead, the server processes these templates, fills them with data, and then 
sends the resulting HTML page to the client. This is in contrast to static 
files in the `public` folder, which are sent to the client as-is.

### Key Aspects of the `views` Folder

  * **Template Engine**: The `views` folder works with a **template engine**, 
  such as EJS (Embedded JavaScript). Your Express.js
  server is configured to know which folder to look in for these files and
  which engine to use to process them. For example, in an Express app, you
  would set the view engine and views directory like this:

    ```javascript
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    ```

  * **Server-Side Rendering**: When a user makes a request to a route, your
  server-side code fetches data (e.g., from a database), and then calls a
  method like `res.render()`. This method takes the name of a file from your
  `views` folder and passes the data to it. The template engine then merges
  the data with the template to create a complete HTML file.

  * **Separation of Concerns**: Storing templates in a dedicated `views`
  folder helps separate the application's **presentation logic** (how the
  page looks) from the **business logic** (how the data is processed). This
  makes your code more organized and easier to maintain.

