Packages:
Mocha - A JavaScript test framework for Node.js programs.

Chai - A BDD / TDD assertion library for node and the browser that can be
delightfully paired with any javascript testing framework.

Jest - Maybe for frontend?

Standard name of Compose filename:
https://docs.docker.com/compose/intro/compose-application-model/

SETUP TOOLS:
https://medium.com/@oliviarizona/eslint-recommended-7d3e6d5dc1aa

https://www.reddit.com/r/node/comments/14jh6hz/do_you_use_eslintconfigairbnb_if_so_why_if_not_why/
I prefer to use eslint:recommended + prettier:recommended instead.

For clarity. As for devs/humans, it's easy to distinguish between a module
file(.mjs) and a normal javascript file(.js)... because it's not always easy
to determine even if you examine the code in the file.

There are also performance benefits which gives you more reason to consider
using it. V8(JavaScript engine that powers Google Chrome) recommends the use
of .mjs but it still depends on your situation. If you want to know more of
it's advantages, check https://v8.dev/features/modules#mjs

**Knex.js library**
A SQL query builder is a tool that helps you write SQL queries using JavaScript
code instead of raw SQL strings. It provides a chainable, object-oriented
interface for building queries.

This approach has several benefits:

Security: It protects against SQL injection attacks by automatically
sanitizing input.

Portability: You can use the same JavaScript code to generate SQL for
different database types (e.g., MySQL, PostgreSQL, SQLite) by simply
changing the configuration.

Readability: It makes your code cleaner and easier to read and maintain,
especially for complex queries.

Parameter binding is a method is the primary defense against SQL injection
attacks. Instead of building a single string by concatenating a query with
user input, you send two distinct pieces of information to the database: a
static query template and the data values.

```
your-project/
├── backend/
│   ├── src/  contains everything that makes your server-side application logic run.
                These files are processed on the server and are not directly
                accessible from the user's browser.
                This is where your main Express.js file lives, along with your
                routes, models, and other server-specific code. This keeps
                your application's core logic separate from configuration
                files and static assets.
│   │   ├── index.mjs       # Your main backend server startup file in order to run in a Node.js environment
│   │   ├── server.mjs       # Your main Express.js application file
│   │   └── routes/      # Your server-side routing logic
│   │   └── models/      # Your database interaction logic
│   │
│   ├── public/ The public/ folder is where you put all of your static files.

      These are assets that are intended to be served directly to the client's web
      browser without any server-side processing. Your Express.js server is
      configured to make these files publicly accessible.

      Static Assets: This is where you store files like:

      bootstrap.min.css: Your CSS stylesheets.

      bootstrap.bundle.min.js: Your JavaScript files.

      images/: Any images your website uses.

      index.html: A static HTML file, if you're not using a template engine like EJS.

      The purpose of the public/ folder is to act as the web-facing part of your
      application. When a user requests http://yourdomain.com/css/bootstrap.min.css,
      your Express.js server looks for that file in the public/ directory and sends
      it directly to the browser.

│   │   ├── css/
│   │   │   └── bootstrap.min.css
│   │   ├── js/
│   │   │   └── bootstrap.bundle.min.js
│   │   └── index.html   # CRIT: Your MAIN Bootstrap LAYOUT HTML frontend files
│   │
│   ├── views/           #  For your EJS templates

    In your views folder:

      - layouts/: This folder contains your main, reusable layout files.
      These are the "master" templates that define the overall HTML
      structure of your website, including the <head> and <body> tags.
      You might have a file like main.ejs here.

      - partials/: This folder is for small, reusable components that
      you'll include in multiple views. Think of things like your navigation
      bar, header, and footer. This prevents you from copying and pasting
      the same code everywhere. For example, _header.ejs or _footer.ejs.

      - pages/: This is where you put your main page-specific files, such
      as homepage.ejs, about.ejs, or contact.ejs. Each file here corresponds
      to a specific page or route in your application.

│   │
│   ├── Dockerfile
│   ├── package.json
│   └── package-lock.json
│
├── db/
│   └── password.txt     # Your database password file for Docker secrets
│
└── compose.yaml
```

-----

### Key Takeaways from This Structure

  * Single-Source of Truth: All your application code, both frontend
  and backend, now lives under the **`backend/`** directory. This is the
  hallmark of a monolithic application.
  
  * Docker Context: The `backend/` directory serves as the **build
  context** for your `backend` service in `docker-compose.yml`. When Docker
  builds the image, it will copy everything from this directory, including
  your static `public` assets and `EJS` views.
  
  * Static Files: Your Bootstrap files are placed in a `public/`
  directory, which your Express.js server will be configured to serve
  as static assets.
  
  *  Your single `backend` service is now responsible for everything.


The purpose of the **`views`** folder is to store the **templates** your web 
application uses to render dynamic HTML. It is a key part of the server-side 
rendering process in frameworks like Express.js.

The content in this folder is not directly accessible to a user's web browser. 
Instead, the server processes these templates, fills them with data, and then 
sends the resulting HTML page to the client. This is in contrast to static 
files in the `public` folder, which are sent to the client as-is.

### Key Aspects of the `views` Folder

  * **Template Engine**: The `views` folder works with a **template engine**, 
  such as EJS (Embedded JavaScript). Your Express.js
  server is configured to know which folder to look in for these files and
  which engine to use to process them. For example, in an Express app, you
  would set the view engine and views directory like this:

    ```javascript
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    ```

  * **Server-Side Rendering**: When a user makes a request to a route, your
  server-side code fetches data (e.g., from a database), and then calls a
  method like `res.render()`. This method takes the name of a file from your
  `views` folder and passes the data to it. The template engine then merges
  the data with the template to create a complete HTML file.

  * **Separation of Concerns**: Storing templates in a dedicated `views`
  folder helps separate the application's **presentation logic** (how the
  page looks) from the **business logic** (how the data is processed). This
  makes your code more organized and easier to maintain.



**Main Layout and Partials**
You can use main.ejs as your main primary layout file. This file will contain
the shared HTML structure for your entire website, such as the <html>, <head>,
and <body> tags. Inside this layout, you will then include partials for
reusable components.

Partials: These are small, reusable .ejs files for components like your
navigation bar, header, and footer. This prevents you from having to copy
and paste the same code on every page. For example, you might have
partials/header.ejs and partials/footer.ejs.

**Page-Specific Files**
You will then create separate .ejs files for the unique content of each page.
The server will render these specific files based on the route requested by the user.

Homepage: A homepage.ejs file would contain the content for your home page.

Edit Page: An edit.ejs file would contain the form and logic for editing an item.