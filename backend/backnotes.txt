Color Palette:
Foreground (Text): #FFFFFF (White)
Background: #889E70 (Sage/Olive Green)

Hypens vs Underscores for image names on website
TDLR: Use Hypens
https://webmasters.stackexchange.com/questions/127555/hypens-vs-underscores-for-image-names-on-website 

Packages:
Mocha - A JavaScript test framework for Node.js programs.

Chai - A BDD / TDD assertion library for node and the browser that can be
delightfully paired with any javascript testing framework.

Jest - Maybe for frontend?

Nodemon - A tool that automatically restarts your Node.js application
whenever it detects changes in your code, making live coding more efficient.
By using nodemon, you can save time during development as it eliminates
the need to manually stop and restart your server after each change.
NOTE: Nodemon restarts the server, but that's only half of "live coding."

Since you are using a server-side rendered application with Express and EJS, 
any changes you make to your server-side code (Node/Express logic,
EJS templates, etc.) require the server to restart to take effect.
Usage: Instead of running your app with node app.js, you run it with nodemon
app.js (or whatever your entry file is).

This setup gives you a "live" development experience by automating the
necessary server restarts for your backend and templating logic.

For Client-Side Changes (Bootstrap & CSS)
While Nodemon handles the server and EJS side, for a better experience with
purely client-side code changes (like your Bootstrap styling or any frontend
JavaScript), you might also consider an additional tool:

BrowserSync: A utility that synchronizes file changes and interactions across
multiple devices. You can configure it to watch for changes to your static
assets (like your CSS files) and inject those changes directly into the
browser without a full page refresh. Integrating it with an Express server
can be slightly more involved than Nodemon, but it offers the fastest feedback
loop for styling.

CRIT: Integrating BrowserSync with a server-side rendered application in a 
Dockerized environment can be complex. If the goal is simply live coding with
minimal setup, you should stick with just Nodemon.

The browser-sync-server.mjs file is the central piece of your new
live-coding workflow. It replaces your simple index.mjs as the server
startup file during development.
This file's job is to start your Express server and then wrap it with
BrowserSync so that static file changes can be injected without a full page
reload.


Standard name of Compose filename:
https://docs.docker.com/compose/intro/compose-application-model/

SETUP TOOLS:
https://medium.com/@oliviarizona/eslint-recommended-7d3e6d5dc1aa

https://www.reddit.com/r/node/comments/14jh6hz/do_you_use_eslintconfigairbnb_if_so_why_if_not_why/
I prefer to use eslint:recommended + prettier:recommended instead.

For clarity. As for devs/humans, it's easy to distinguish between a module
file(.mjs) and a normal javascript file(.js)... because it's not always easy
to determine even if you examine the code in the file.

There are also performance benefits which gives you more reason to consider
using it. V8(JavaScript engine that powers Google Chrome) recommends the use
of .mjs but it still depends on your situation. If you want to know more of
it's advantages, check https://v8.dev/features/modules#mjs

**Knex.js library**
A SQL query builder is a tool that helps you write SQL queries using JavaScript
code instead of raw SQL strings. It provides a chainable, object-oriented
interface for building queries.

This approach has several benefits:

Security: It protects against SQL injection attacks by automatically
sanitizing input.

Portability: You can use the same JavaScript code to generate SQL for
different database types (e.g., MySQL, PostgreSQL, SQLite) by simply
changing the configuration.

Readability: It makes your code cleaner and easier to read and maintain,
especially for complex queries.

Parameter binding is a method is the primary defense against SQL injection
attacks. Instead of building a single string by concatenating a query with
user input, you send two distinct pieces of information to the database: a
static query template and the data values.

```
your-project/
├── backend/
│   ├── src/  contains everything that makes your server-side application logic run.
                These files are processed on the server and are not directly
                accessible from the user's browser.
                This is where your main Express.js file lives, along with your
                routes, models, and other server-specific code. This keeps
                your application's core logic separate from configuration
                files and static assets.
│   │   ├── index.mjs       # Your main backend server startup file in order to run in a Node.js environment
│   │   ├── server.mjs       # Your main Express.js application file
│   │   └── routes/      # Your server-side routing logic
│   │   └── models/      # Your database interaction logic
│   │
│   ├── public/ The public/ folder is where you put all of your static files.

      These are assets that are intended to be served directly to the client's web
      browser without any server-side processing. Your Express.js server is
      configured to make these files publicly accessible.

      Static Assets: This is where you store files like:

      bootstrap.min.css: Your CSS stylesheets.

      bootstrap.bundle.min.js: Your JavaScript files.

      images/: Any images your website uses.

      index.html: A static HTML file, if you're not using a template engine like EJS.

      The purpose of the public/ folder is to act as the web-facing part of your
      application. When a user requests http://yourdomain.com/css/bootstrap.min.css,
      your Express.js server looks for that file in the public/ directory and sends
      it directly to the browser.

│   │   ├── css/
│   │   │   └── bootstrap.min.css
│   │   ├── js/
│   │   │   └── bootstrap.bundle.min.js
│   │   └── index.html   # CRIT: Your MAIN Bootstrap LAYOUT HTML frontend files
│   │
│   ├── views/           #  For your EJS templates

    In your views folder:

      - layouts/: This folder contains your main, reusable layout files.
      These are the "master" templates that define the overall HTML
      structure of your website, including the <head> and <body> tags.
      You might have a file like main.ejs here.

      - partials/: This folder is for small, reusable components that
      you'll include in multiple views. Think of things like your navigation
      bar, and user error messages. This prevents you from copying and pasting
      the same code everywhere.

      - pages/: This is where you put your main page-specific files, such
      as homepage.ejs, about.ejs, or contact.ejs. Each file here corresponds
      to a specific page or route in your application.

│   │
│   ├── Dockerfile
│   ├── package.json
│   └── package-lock.json
│
├── db/
│   └── password.txt     # Your database password file for Docker secrets
│
└── compose.yaml
```

-----

### Key Takeaways from This Structure

  * Single-Source of Truth: All your application code, both frontend
  and backend, now lives under the **`backend/`** directory. This is the
  hallmark of a monolithic application.
  
  * Docker Context: The `backend/` directory serves as the **build
  context** for your `backend` service in `docker-compose.yml`. When Docker
  builds the image, it will copy everything from this directory, including
  your static `public` assets and `EJS` views.
  
  * Static Files: Your Bootstrap files are placed in a `public/`
  directory, which your Express.js server will be configured to serve
  as static assets.
  
  *  Your single `backend` service is now responsible for everything.


The purpose of the **`views`** folder is to store the **templates** your web 
application uses to render dynamic HTML. It is a key part of the server-side 
rendering process in frameworks like Express.js.

The content in this folder is not directly accessible to a user's web browser. 
Instead, the server processes these templates, fills them with data, and then 
sends the resulting HTML page to the client. This is in contrast to static 
files in the `public` folder, which are sent to the client as-is.

### Key Aspects of the `views` Folder

  * **Template Engine**: The `views` folder works with a **template engine**, 
  such as EJS (Embedded JavaScript). Your Express.js
  server is configured to know which folder to look in for these files and
  which engine to use to process them. For example, in an Express app, you
  would set the view engine and views directory like this:

    ```javascript
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    ```

  * **Server-Side Rendering**: When a user makes a request to a route, your
  server-side code fetches data (e.g., from a database), and then calls a
  method like `res.render()`. This method takes the name of a file from your
  `views` folder and passes the data to it. The template engine then merges
  the data with the template to create a complete HTML file.

  * **Separation of Concerns**: Storing templates in a dedicated `views`
  folder helps separate the application's **presentation logic** (how the
  page looks) from the **business logic** (how the data is processed). This
  makes your code more organized and easier to maintain.



**Main Layout and Partials**
You can use main.ejs as your main primary layout file. This file will contain
the shared HTML structure for your entire website, such as the <html>, <head>,
and <body> tags. Inside this layout, you will then include partials for
reusable components.

Partials: These are small, reusable .ejs files for components like your
navigation bar, header, and footer. This prevents you from having to copy
and paste the same code on every page. For example, you might have
partials/header.ejs and partials/footer.ejs.

**Page-Specific Files**
You will then create separate .ejs files for the unique content of each page.
The server will render these specific files based on the route requested by the user.

Homepage: A homepage.ejs file would contain the content for your home page.

Edit Page: An edit.ejs file would contain the form and logic for editing an item.


Individual pages then "inject" their specific content into a designated area of the layout file.

he Purpose of Multiple Layouts
You are right: the purpose of having two separate layout files—one minimal and one full-featured—is to serve different needs within the same application.

- main.ejs (The Minimal BASE Layout): This would be used for pages that are self-contained and don't require the full application UI. This could include pages like:

  - Login or Signup pages: These need to be simple and distraction-free.

  - Password recovery forms: A clean, single-purpose page.

  - Error pages: A page that shows a simple error message without the full navigation.

Using a minimal layout for these pages keeps the code cleaner, reduces unnecessary file loads (like extra CSS or JavaScript), and improves performance.

- layout-main.ejs (The Common BASE Layout): This is the standard layout for the main parts of your application. It includes all the common components that most pages share, such as:

  - A full navigation sidebar.

  - A header with a user profile or notifications.

  - A footer.

  - All the necessary JavaScript libraries for the application's functionality.

This approach ensures a consistent user experience and avoids repeating the same code on every page that needs the full UI.


A common practice in web development is to separate the BASE minimal layout page (e.g. main.ejs) from the
content page. This is often achieved using a base template that contains the
shared elements of a website,  such as:

- HTML <head> section (meta tags, CSS links)
- Header and navigation bars
- Footer

To eventually, have a separate BASE layout page + separate content page united as one using Express.js