Color Palette:
Foreground (Text): #FFFFFF (White)
Background: #889E70 (Sage/Olive Green)

Hypens vs Underscores for image names on website
TDLR: Use Hypens
https://webmasters.stackexchange.com/questions/127555/hypens-vs-underscores-for-image-names-on-website 

CRIT: URL structure best practices for Google Search
https://developers.google.com/search/docs/crawling-indexing/url-structure?hl=en&visit_id=638966875065547045-297040226&rd=1

Packages:
Mocha - A JavaScript test framework for Node.js programs.

Chai - A BDD / TDD assertion library for node and the browser that can be
delightfully paired with any javascript testing framework.

Jest - Maybe for frontend?

Nodemon - A tool that automatically restarts your Node.js application
whenever it detects changes in your code, making live coding more efficient.
By using nodemon, you can save time during development as it eliminates
the need to manually stop and restart your server after each change.
NOTE: Nodemon restarts the server, but that's only half of "live coding."

Since you are using a server-side rendered application with Express and EJS, 
any changes you make to your server-side code (Node/Express logic,
EJS templates, etc.) require the server to restart to take effect.
Usage: Instead of running your app with node app.js, you run it with nodemon
app.js (or whatever your entry file is).

This setup gives you a "live" development experience by automating the
necessary server restarts for your backend and templating logic.

For Client-Side Changes (Bootstrap & CSS)
While Nodemon handles the server and EJS side, for a better experience with
purely client-side code changes (like your Bootstrap styling or any frontend
JavaScript), you might also consider an additional tool:

BrowserSync: A utility that synchronizes file changes and interactions across
multiple devices. You can configure it to watch for changes to your static
assets (like your CSS files) and inject those changes directly into the
browser without a full page refresh. Integrating it with an Express server
can be slightly more involved than Nodemon, but it offers the fastest feedback
loop for styling.

CRIT: Integrating BrowserSync with a server-side rendered application in a 
Dockerized environment can be complex. If the goal is simply live coding with
minimal setup, you should stick with just Nodemon.

The browser-sync-server.mjs file is the central piece of your new
live-coding workflow. It replaces your simple index.mjs as the server
startup file during development.
This file's job is to start your Express server and then wrap it with
BrowserSync so that static file changes can be injected without a full page
reload.


Standard name of Compose filename:
https://docs.docker.com/compose/intro/compose-application-model/

SETUP TOOLS:
https://medium.com/@oliviarizona/eslint-recommended-7d3e6d5dc1aa

https://www.reddit.com/r/node/comments/14jh6hz/do_you_use_eslintconfigairbnb_if_so_why_if_not_why/
I prefer to use eslint:recommended + prettier:recommended instead.

For clarity. As for devs/humans, it's easy to distinguish between a module
file(.mjs) and a normal javascript file(.js)... because it's not always easy
to determine even if you examine the code in the file.

There are also performance benefits which gives you more reason to consider
using it. V8(JavaScript engine that powers Google Chrome) recommends the use
of .mjs but it still depends on your situation. If you want to know more of
it's advantages, check https://v8.dev/features/modules#mjs

**Knex.js library**
A SQL query builder is a tool that helps you write SQL queries using JavaScript
code instead of raw SQL strings. It provides a chainable, object-oriented
interface for building queries.

This approach has several benefits:

Security: It protects against SQL injection attacks by automatically
sanitizing input.

Portability: You can use the same JavaScript code to generate SQL for
different database types (e.g., MySQL, PostgreSQL, SQLite) by simply
changing the configuration.

Readability: It makes your code cleaner and easier to read and maintain,
especially for complex queries.

Parameter binding is a method is the primary defense against SQL injection
attacks. Instead of building a single string by concatenating a query with
user input, you send two distinct pieces of information to the database: a
static query template and the data values.

```
your-project/
├── backend/
│   ├── src/  contains everything that makes your server-side application logic run.
                These files are processed on the server and are not directly
                accessible from the user's browser.
                This is where your main Express.js file lives, along with your
                routes, models, and other server-specific code. This keeps
                your application's core logic separate from configuration
                files and static assets.
│   │   ├── index.mjs       # Your main backend server startup file in order to run in a Node.js environment
│   │   ├── server.mjs       # Your main Express.js application file
│   │   └── routes/      # Your server-side routing logic
│   │   └── models/      # Your database interaction logic
│   │
│   ├── public/ The public/ folder is where you put all of your static files.

      These are assets that are intended to be served directly to the client's web
      browser without any server-side processing. Your Express.js server is
      configured to make these files publicly accessible.

      Static Assets: This is where you store files like:

      bootstrap.min.css: Your CSS stylesheets.

      bootstrap.bundle.min.js: Your JavaScript files.

      images/: Any images your website uses.

      index.html: A static HTML file, if you're not using a template engine like EJS.

      The purpose of the public/ folder is to act as the web-facing part of your
      application. When a user requests http://yourdomain.com/css/bootstrap.min.css,
      your Express.js server looks for that file in the public/ directory and sends
      it directly to the browser.

│   │   ├── css/
│   │   │   └── bootstrap.min.css
│   │   ├── js/
│   │   │   └── bootstrap.bundle.min.js
│   │   └── index.html   # CRIT: Your MAIN Bootstrap LAYOUT HTML frontend files
│   │
│   ├── views/           #  For your EJS templates

    In your views folder:

      - layouts/: This folder contains your main, reusable layout files.
      These are the "master" templates that define the overall HTML
      structure of your website, including the <head> and <body> tags.
      You might have a file like main.ejs here.

      - partials/: This folder is for small, reusable components that
      you'll include in multiple views. Think of things like your navigation
      bar, and user error messages. This prevents you from copying and pasting
      the same code everywhere.

      - pages/: This is where you put your main page-specific files, such
      as homepage.ejs, about.ejs, or contact.ejs. Each file here corresponds
      to a specific page or route in your application.

│   │
│   ├── Dockerfile
│   ├── package.json
│   └── package-lock.json
│
├── db/
│   └── password.txt     # Your database password file for Docker secrets
│
└── compose.yaml
```

-----

### Key Takeaways from This Structure

  * Single-Source of Truth: All your application code, both frontend
  and backend, now lives under the **`backend/`** directory. This is the
  hallmark of a monolithic application.
  
  * Docker Context: The `backend/` directory serves as the **build
  context** for your `backend` service in `docker-compose.yml`. When Docker
  builds the image, it will copy everything from this directory, including
  your static `public` assets and `EJS` views.
  
  * Static Files: Your Bootstrap files are placed in a `public/`
  directory, which your Express.js server will be configured to serve
  as static assets.
  
  *  Your single `backend` service is now responsible for everything.


The purpose of the **`views`** folder is to store the **templates** your web 
application uses to render dynamic HTML. It is a key part of the server-side 
rendering process in frameworks like Express.js.

The content in this folder is not directly accessible to a user's web browser. 
Instead, the server processes these templates, fills them with data, and then 
sends the resulting HTML page to the client. This is in contrast to static 
files in the `public` folder, which are sent to the client as-is.

### Key Aspects of the `views` Folder

  * **Template Engine**: The `views` folder works with a **template engine**, 
  such as EJS (Embedded JavaScript). Your Express.js
  server is configured to know which folder to look in for these files and
  which engine to use to process them. For example, in an Express app, you
  would set the view engine and views directory like this:

    ```javascript
    app.set('view engine', 'ejs');
    app.set('views', path.join(__dirname, 'views'));
    ```

  * **Server-Side Rendering**: When a user makes a request to a route, your
  server-side code fetches data (e.g., from a database), and then calls a
  method like `res.render()`. This method takes the name of a file from your
  `views` folder and passes the data to it. The template engine then merges
  the data with the template to create a complete HTML file.

  * **Separation of Concerns**: Storing templates in a dedicated `views`
  folder helps separate the application's **presentation logic** (how the
  page looks) from the **business logic** (how the data is processed). This
  makes your code more organized and easier to maintain.



**Main Layout and Partials**
You can use main.ejs as your main primary layout file. This file will contain
the shared HTML structure for your entire website, such as the <html>, <head>,
and <body> tags. Inside this layout, you will then include partials for
reusable components.

Partials: These are small, reusable .ejs files for components like your
navigation bar, header, and footer. This prevents you from having to copy
and paste the same code on every page. For example, you might have
partials/header.ejs and partials/footer.ejs.

**Page-Specific Files**
You will then create separate .ejs files for the unique content of each page.
The server will render these specific files based on the route requested by the user.

Homepage: A homepage.ejs file would contain the content for your home page.

Edit Page: An edit.ejs file would contain the form and logic for editing an item.


Individual pages then "inject" their specific content into a designated area of the layout file.

he Purpose of Multiple Layouts
You are right: the purpose of having two separate layout files—one minimal and one full-featured—is to serve different needs within the same application.

- main.ejs (The Minimal BASE Layout): This would be used for pages that are self-contained and don't require the full application UI. This could include pages like:

  - Login or Signup pages: These need to be simple and distraction-free.

  - Password recovery forms: A clean, single-purpose page.

  - Error pages: A page that shows a simple error message without the full navigation.

Using a minimal layout for these pages keeps the code cleaner, reduces unnecessary file loads (like extra CSS or JavaScript), and improves performance.

- layout-main.ejs (The Common BASE Layout): This is the standard layout for the main parts of your application. It includes all the common components that most pages share, such as:

  - A full navigation sidebar.

  - A header with a user profile or notifications.

  - A footer.

  - All the necessary JavaScript libraries for the application's functionality.

This approach ensures a consistent user experience and avoids repeating the same code on every page that needs the full UI.


A common practice in web development is to separate the BASE minimal layout page (e.g. main.ejs) from the
content page. This is often achieved using a base template that contains the
shared elements of a website,  such as:

- HTML <head> section (meta tags, CSS links)
- Header and navigation bars
- Footer

To eventually, have a separate BASE layout page + separate content page united as one using Express.js

CRIT: Creating a simple custom.scss file is the industry-standard, clean,
and maintainable way to customize any Sass framework.

sass public/bootstrap-5.3.8/scss/custom.scss:public/bootstrap-5.3.8/dist/css/custom-bootstrap.css

The controllers folder is a directory used in software development,
particularly within web frameworks that follow the
Model-View-Controller (MVC) architectural pattern.

In the context of your Node.js/Express project, the controllers folder houses
the files responsible for the application logic and managing the flow of
data between the front-end and the database.

## user-controller.mjs ##
Implies Responsibility.
Create, Read, Update, Delete (CRUD) operations for the User resource,
plus login/logout.	Standard convention (MVC pattern). It tells any
developer that this file handles all application logic for the User resource.


However, you have placed the body parser middleware after your routes are
loaded, which means Express processes the routes before it tries to read
the request body, leaving req.body as undefined.

**CRIT: In Express, middleware is executed in the order it is defined.**

https://stackoverflow.com/questions/19867599/what-is-the-difference-between-localstorage-sessionstorage-session-and-cookies#19869560
What is the difference between localStorage, sessionStorage, session and cookies?

HTTP cookie - A small block of data created by a web server that websites
store on your computer to remember information about your visit, such as
login details or items in your shopping cart. They help personalize your
browsing experience and track your activity across the web. Cookies are
placed on the device used to access a website, and more than one cookie
may be placed on a user's device during a session.

LocalStorage is for long-term storage, retaining data even after the browser
is closed, while sessionStorage is temporary and clears data when the tab is
closed. Cookies are smaller (about 4KB), can be sent to the server with each
request, and can have expiration dates, making them suitable for session
management and tracking.

A lot of the pros/cons will be contextual to the situation.

In all cases, these storage mechanisms will be specific to an individual
browser on an individual computer/device. Any requirement to store data on
an ongoing basis across sessions will need to involve your application server 
side - most likely using a database, but possibly XML or a text/CSV file.

LocalStorage, sessionStorage, and cookies are all client storage solutions.
Session data is held on the server where it remains under your direct control.

TLDR:
Beware: sessionStorage, localStorage are not appropriate for authentication
information. They are not automatically sent to the server. This means that
if a user changes the URL manually, or clicks on HTML links, you will not get
authentication information. Even if you rewrite HTML links, you are forced to
pass the authentication information over the URL which is a security no-no.
At the end of the day, you will be forced to use Cookies.
See stackoverflow.com/q/26556749/14731 for a related topic.


Session - A temporary connection between a client and a server that allows
for the exchange of information during a user's visit to a website. Sessions
are often managed using session IDs, which help track user activity and
maintain state across multiple requests.

#####
1. express-session creates the user's session object.

2. express-mysql-session ensures that session object is saved to MySQL.

3. connect-flash writes your message (req.flash('success', 'Hi!')) into that 
session object, and then reads and deletes it on the next request.
#####


**CRIT: express-sessio creates a session using a cookie, but
it's important to understand what the cookie contains. **

The Session Flow:
1. First Request: A user visits your site. express-session generates a unique, random string called the Session ID.

2. Cookie Creation: This Session ID is placed into a cookie (often named connect.sid by default) and sent back to the browser in the HTTP response header.

3. Subsequent Requests: The browser automatically sends the Session ID cookie back to the server with every subsequent request.

4. Data Lookup: The express-session middleware intercepts this cookie, reads the Session ID, and uses that ID to retrieve the full, associated session data (which contains all the variables you've stored, like login status or flash messages) from the server's store (MemoryStore, MySQL, Redis, etc.).

CRIT: The cookie itself does NOT contain the session data (like the user's
name or password). It only contains the Session ID, which acts as a secure,
temporary key to unlock the data stored safely on your server (e.g., in your
MySQL database). This separation is a vital security feature.

CRIT: NPM: The -D flag, or its longer form --save-dev, is used with the npm
install command to install a package as a development dependency.
(i.e. Development Dependencies: These are packages needed only for developing
and testing your project.)
(Vice versa: Production Dependencies )

Request Object. (i.e. key 'session' of class instance 'Session')
req : session: Session

GOAT: Show Table Full details command:
SHOW CREATE TABLE books;

CRIT: JavaScript Unpack from Object or Arrays
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring 

C00000
C1 

The actual date on which the borrowed item was successfully checked back into
the system by the borrower.


COOL: When multiple HTML input elements share the exact same $\text{name}$ attribute,
such as copyId[], and they are part of a form that is submitted, their values
are typically sent to the server as an array or list of values under that
single name.
